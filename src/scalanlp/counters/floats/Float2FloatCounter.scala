// THIS IS AN AUTO-GENERATED CLASS. DO NOT MODIFY.    
// generated by GenCounter on Wed Jul 30 12:05:37 PDT 2008
package scalanlp.counters.floats;

import scala.collection.mutable.Map;
import scala.collection.mutable.HashMap;

trait Float2FloatCounter extends FloatCounter[Float] {


  abstract override def update(k : Float, v : Float) = {

    super.update(k,v);
  }

  // this isn't necessary, except that the jcl MapWrapper overrides put to call Java's put directly.
  override def put(k : Float, v : Float) :Option[Float] = { val old = get(k); update(k,v); old}

  abstract override def -=(key : Float) = {

    super.-=(key);
  }
  override def default(k : Float) : Float = 0;

  override def apply(k : Float) : Float = super.apply(k);



  // TODO: clone doesn't seem to work. I think this is a JCL bug.
  override def clone(): Float2FloatCounter  = super.clone().asInstanceOf[Float2FloatCounter]

  override  def argmax() : Float = (elements reduceLeft ((p1:(Float,Float),p2:(Float,Float)) => if (p1._2 > p2._2) p1 else p2))._1
  override  def argmin() : Float = (elements reduceLeft ((p1:(Float,Float),p2:(Float,Float)) => if (p1._2 < p2._2) p1 else p2))._1

  override  def max : Float = values reduceLeft ((p1:Float,p2:Float) => if (p1 > p2) p1 else p2)
  override  def min : Float = values reduceLeft ((p1:Float,p2:Float) => if (p1 < p2) p1 else p2)

  override  def comparator(a : Float, b :Float) = apply(a) compare apply(b);

  override  def normalized : Float2DoubleCounter = {
    val normalized = new HashMap[Float,Double]() with Float2DoubleCounter;
    val total : Double = this.total
    for (pair <- elements) {
      normalized.put(pair._1,pair._2 / total)
    }
    normalized
  }

  override  def l2norm() : Double = {
    var norm = 0.0
    for (val v <- values) {
      norm += (v * v)
    }
    return Math.sqrt(norm)
  }

  override  def topK(k : Int) = Counters.topK[(Float,Float)](k,(x,y) => (x._2-y._2).asInstanceOf[Int])(this);

  def dot(that : Float2FloatCounter) : Double = {
    var total = 0.0
    for (val (k,v) <- that.elements) {
      total += get(k).asInstanceOf[Double] * v
    }
    return total
  }

  def +=(that : Float2FloatCounter) {
    for(val (k,v) <- that.elements) {
      update(k,(this(k) + v).asInstanceOf[Float]);
    }
  }

  override  def +=(that : Iterable[(Float,Float)]) {
    for(val (k,v) <- that) {
      this(k) = (this(k) + v).asInstanceOf[Float];
    }
  }


}


object Float2FloatCounter {
  import it.unimi.dsi.fastutil.objects._
  import it.unimi.dsi.fastutil.ints._
  import it.unimi.dsi.fastutil.shorts._
  import it.unimi.dsi.fastutil.longs._
  import it.unimi.dsi.fastutil.floats._
  import it.unimi.dsi.fastutil.doubles._


  import scala.collection.jcl.MapWrapper;
  def apply() = new MapWrapper[Float,Float] with Float2FloatCounter {
    private val under = new Float2FloatOpenHashMap;
    def underlying() = under.asInstanceOf[java.util.Map[Float,Float]];
    override def apply(x : Float) = under.get(x);
    override def update(x : Float, v : Float) {
      val oldV = this(x);
      updateTotal(v-oldV);
      under.put(x,v);
    }
  }

  
}

